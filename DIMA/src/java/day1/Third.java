/*
 * 변수를 선언하고 값을 저장한 후 연산 
 */
package java.day1;

public class Third {
	// 멤버 변수 (힙 메모리에 쌓여서 자동으로 초기화가 된다.) 
	int age;
	
	public static void main(String[] args) {
		// 선언 - 초기화 - 연산 - 출력 의 순서를 항상 지켜야한다!!
		
		
		// 메서드 안에서 선언 -> 지역 변수 (Local Variable)
		// 지역 변수 규칙 : 선언 후 초기화한 다음 사용 (값을 넣어줘야한다.) 
			// 스택메모리에 생성 -> 쓰레기값 허용 X 
			// 해당 메소드({})가 닫기는 순간 메모리에서 삭제
		int age;           // 선언
		age = 10;          // 초기화 (값을 처음 넣어주는 것이 초기화)
		// 여기서 10은 2진수로 변환되어 저장된다. 
		// 0000 0000 0000 0000 0000 0000 0000 1010 (32bit의 10)
		
//		int age = 0;      // 선언과 동시에 초기화 가능
//		int age;           // 같은 지역 안에서 같은 이름의 변수 재선언 불가 
		
//		byte by = -130;   // 오류 (-128이 최소값) 
		byte by = -128;
		System.out.println(by);
//		by + 1;              // 실행문X 표현식O 
//		by = by + 1  // 연산을 할 때에는 기본적으로 int, double 기본으로 사용 -> 타입이 달라서 오류가 뜬다. 
		// promotion - 연산 시 타입이 다르면 내부적으로 타입을 맞추는 동작 (큰타입에 맞춰짐)
		// byte + int => int + int => int ==> 작은 변수에 큰 값을 넣으려는 동작 실행 -> convert 불가 오류 
		// byte는 연산 시 사용 X 
		
		double area = 5 * 5 * 3.14; // int로 선언 시 에러,, (3.14 때문에)
		
		short sh = 45;
		sh = 45 * 2;      // 
//		sh = sh * 2;      // Error
		
		//선언 후 사용하지 않은 변수들은 알려준다.(메모리 낭비 방지)
		
		//      1111 1111 1111 1111 1111 1111 1111 1111 (-1의 2진수)
		//      0000 0000 0000 0000 0000 0000 0000 0001 (1) 
		//    1 0000 0000 0000 0000 0000 0000 0000 0000 (-1 + 1 -> 32bit에서 처리 불가 - overflow 발생 - 유효자릿수가 버려진다.)
		// =>   0000 0000 0000 0000 0000 0000 0000 0000 (결과적으로 0)
		// 2진수에서의 제일 앞자리는 부호를 나타낸다. (보수 표현법) 
		// 퀀텀 메모리 (CPU) 
		int temp = -2147483648 ;    // int의 최솟값 -2147483648
		System.out.println(temp);
		
		temp = temp - 1;             // Error가 아닌 2147483647의 결과가 뜬다. 
		System.out.println(temp);
		
//		temp = 가장 큰 값 ; // 제일 앞 자리가 0이면 양수 !
		// 0111 1111 .... 1111
//		temp = temp + 1 ;    // 가장 작은 값 
		// 0000 0000 .... 0001 (1)을 더하면
		// 1000 0000 .... 0000 -> 음수로 표현 가능한 가장 작은 값 
				
		// 정수를 2의 보수 표현법을 사용하기 때문에 해당 현상 발생 (실수의 경우 다르다.)
		// 가장 큰 값 + 1 = 가장 작은 값 
		// 가장 작은 값 -1 = 가장 큰 값 

		// 정수는 0이 한 개 (0) 
//		temp = 256 / 0 ; // 불가능한 연산 Exception 
		
		// 실수는 0이 두 개 (0.0, -0.0)
		// IEEE 754
		// 실수는 메모리에 저장될 때 분해되어 들어간다. (부호 + 지수 + 가수)
		// -0.01 * 2 ^ 12 (부호 가수 지수) (전체의 부호 & 지수의 부호도 따로 저장) 
		// ==> -.1 -> .의 위치는 정해둔다. 
		// -0.01 * 2 ^ 12 =(float point - 점이 정해진 위치로 움직인다.)=> -1 * 2^-11 ==> -, 1, -11
		// 원래수의 음수, 지수부의 음수까지 표현해야하기 때문에 0이 두개 
		
		// 0.0과 -0.0은 0이 아닌 굉장히 작은 무한 수 (근데 사실 쓸 일 X)  
		double dbl = 45 / 0.0 ;      // int / float 지만 연산이 된다. (0.0은 저장할 수 없을 정도로 작은 수 -> 무한수 (Infinity))
		// double dbl = 45 / -0.0 ;  // 음수도 가능 ==> - Infinity
		System.out.println(dbl);
		
		// 0.1 / 0  ; 타입 변환 float / float ==> Infinity
		
		double a = 0.1;
		double b = 0.3;         
		double c = a + b;
		
		System.out.println(c == 0.4);   // true

		
		double d = 0.1;
		double e = 0.2;        // 10진수 ==> 2진수 ==> 오차 ==> float < double 선호  
		double f = d + e;
		
		// 데이터 찌꺼기 오차 
		System.out.println(f == 0.3);   // true여야하는데 false가 뜬다.
		System.out.println(d + ", " + e + ", " + f); // 데이터 찌꺼기가 들어간다. (10진수 -> 2진수 변환 시 오차 발생 - 필연적) 
		// 데이터 찌꺼기의 오차 때문에 실수형 데이터를 동등연산자로 비교하면 안 된다.
//		System.out.println(f == 0.3);
		
		
		System.out.println();
		
		// byte b1 = (byte)(127 + 1) ; 일 때 b1의 값은? ? 캐스팅? 형변환? byte의 가장 큰 수인 127에서 1을 더하면 -128
		// byte b2 = 1;
		// b2 = b2 + 2; 의 결과는 ? 
	}

}
